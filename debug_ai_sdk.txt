interface StreamTextResult<TOOLS extends ToolSet, OUTPUT extends Output> {
    /**
  The content that was generated in the last step.
  
  Automatically consumes the stream.
     */
    readonly content: PromiseLike<Array<ContentPart<TOOLS>>>;
    /**
  The full text that has been generated by the last step.
  
  Automatically consumes the stream.
       */
    readonly text: PromiseLike<string>;
    /**
  The full reasoning that the model has generated.
  
  Automatically consumes the stream.
     */
    readonly reasoning: PromiseLike<Array<ReasoningOutput>>;
    /**
  The reasoning that has been generated by the last step.
  
  Automatically consumes the stream.
       */
    readonly reasoningText: PromiseLike<string | undefined>;
    /**
  Files that have been generated by the model in the last step.
  
  Automatically consumes the stream.
     */
    readonly files: PromiseLike<GeneratedFile[]>;
    /**
  Sources that have been used as references in the last step.
  
  Automatically consumes the stream.
     */
    readonly sources: PromiseLike<Source[]>;
    /**
  The tool calls that have been executed in the last step.
  
  Automatically consumes the stream.
       */
    readonly toolCalls: PromiseLike<TypedToolCall<TOOLS>[]>;
    /**
  The static tool calls that have been executed in the last step.
  
  Automatically consumes the stream.
       */
    readonly staticToolCalls: PromiseLike<StaticToolCall<TOOLS>[]>;
    /**
  The dynamic tool calls that have been executed in the last step.
  
  Automatically consumes the stream.
       */
    readonly dynamicToolCalls: PromiseLike<DynamicToolCall[]>;
    /**
  The static tool results that have been generated in the last step.
  
  Automatically consumes the stream.
       */
    readonly staticToolResults: PromiseLike<StaticToolResult<TOOLS>[]>;
    /**
  The dynamic tool results that have been generated in the last step.
  
  Automatically consumes the stream.
       */
    readonly dynamicToolResults: PromiseLike<DynamicToolResult[]>;
    /**
  The tool results that have been generated in the last step.
  
  Automatically consumes the stream.
     */
    readonly toolResults: PromiseLike<TypedToolResult<TOOLS>[]>;
    /**
     * The unified finish reason why the generation finished. Taken from the last step.
     *
     * Automatically consumes the stream.
     */
    readonly finishReason: PromiseLike<FinishReason>;
    /**
     * The raw reason why the generation finished (from the provider). Taken from the last step.
     *
     * Automatically consumes the stream.
     */
    readonly rawFinishReason: PromiseLike<string | undefined>;
    /**
  The token usage of the last step.
  
  Automatically consumes the stream.
     */
    readonly usage: PromiseLike<LanguageModelUsage>;
    /**
  The total token usage of the generated response.
  When there are multiple steps, the usage is the sum of all step usages.
  
  Automatically consumes the stream.
       */
    readonly totalUsage: PromiseLike<LanguageModelUsage>;
    /**
  Warnings from the model provider (e.g. unsupported settings) for the first step.
  
  Automatically consumes the stream.
       */
    readonly warnings: PromiseLike<CallWarning[] | undefined>;
    /**
  Details for all steps.
  You can use this to get information about intermediate steps,
  such as the tool calls or the response headers.
  
  Automatically consumes the stream.
     */
    readonly steps: PromiseLike<Array<StepResult<TOOLS>>>;
    /**
  Additional request information from the last step.
  
  Automatically consumes the stream.
   */
    readonly request: PromiseLike<LanguageModelRequestMetadata>;
    /**
  Additional response information from the last step.
  
  Automatically consumes the stream.
   */
    readonly response: PromiseLike<LanguageModelResponseMetadata & {
        /**
  The response messages that were generated during the call. It consists of an assistant message,
  potentially containing tool calls.
  
  When there are tool results, there is an additional tool message with the tool results that are available.
  If there are tools that do not have execute functions, they are not included in the tool results and
  need to be added separately.
         */
        messages: Array<ResponseMessage>;
    }>;
